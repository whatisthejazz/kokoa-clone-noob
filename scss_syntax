#CSS 명령문
<style>
    h1{
        color: blue;
        font-size: 20px;
    }

#box와 inline 함수
box의 경우 웹사이트 내 레이아웃이 옆으로 오지 않는다 (=block)
inline의 경우, 레이아웃이 옆으로 붙는 함수들 (a, span, img 함수들)
<div></div>
     <div></div>
     <span>hello</span>
     <span>hello</span>
     <span>hello</span>
     <a href="#">link</a>
     <span>hello</span>
     <img
    src="img/다운로드.png" />
    <span>hello</span>
    <span>hello</span>
    <span>hello</span>
   #display 함수를 통해 속성 변경이 가능하다.
   display: inline; or display: block;
   그러나 block 속성을 inline으로 변경 시, div는 웹페이지에서 사라지는데,
   이는 inline 함수는 height와 width를 가질 수 없기 때문
            div{
                display: inline;
                height: 150px;
                width: 150px;
                background-color: tomato;
    
            }
            span{
                display: block;
                background-color: turquoise;
            }
Margin? box(div)의 border(경계)의 바깥에 있는 공간.
방향 설정 없이 margin 하나를 주면 사방에 전부 다 적용된다.
두 개를 줄 경우 상하, 좌우 이다.
네 개를 줄 경우 시계방향 순으로 적용된다. (상 우 하 좌)
Collapsing margin 현상 (상하 방향에서만 발생함)
1번요소가 2번요소 안에 속해 있을 때, 발생하는 현상으로써, 마진값과 관계없이
상,하 공백값이 발생하는 현상. 이 경우 margin이 아닌 padding으로 접근.

padding? border 안 공간. margin과 마찬가지로 방향설정이 가능하며, 하지 않을 경우,
전방향 적용. 우리가 개별 id 별 적용을 하고 싶을 때?(id=first)
#first{
    padding=30px
} --> #id name {속성 value}

<!DOCTYPE html>
<html lang="kr">
    <head>
        <style>
            *{
                border: 2px solid black;
            }
            html {
                background-color: tomato;
            }

            h1{
                color: yellowgreen;
                font-style: italic;
                font-size: 50px;
            }
            div{
                background-color: white;
                padding: 20px;
            }
            body{
                padding: 20px;
                background-color: burlywood;
                margin: 20px;
            }
            span{
                border: 2px dotted black;
            }
            #first{
                background-color: whitesmoke;
                height: 150px;
                width: 150px;
            }
            #second{
                background-color: teal;
                height: 100px;
                width: 100px;
            }
            #third{
                background-color: wheat;
                height: 50px;
                width: 50px;
            }
            #fourth{

            }
            </style>
    </head>
    <body>
    <div id="first">
        <div id="second">
            <div id="third">
                <div id="fourth"><span>hel</span></div>
            </div>
        </div>
    </div>
    </body>
</html>

<style>
.btn{
    color: white;
    padding: 10px;
    border-radius: 10px;
}
.tomato{
    background-color: tomato;
    color: white;
    padding: 10px;
    border-radius: 10px;
}
.teal{
}
#tomato=>id="tomato"
.tomato=>class="tomato"
<span class="btn tomato">hello</span>
<span class="btn teal">hello</span>
<span class="btn tomato">hello</span></style>
#class = "btn tomato teal" class 안 객체들의 뛰어쓰기는 각각의 개체로 본다.
즉, 위 class 안에는 총 3개의 객체가 있는 것. btn,tomato, teal
id는 독립적인 하나의 개체만 저장가능하여 제약이 많지만, class는 여러 객체 저장이
가능하기 때문에 실무에서 자주 사용.
#inline 내 padding, margin 함수 사용 가능. 
다만, inline은 height와 width가 없기 때문에 상,하 공백이 존재한다.
(이 경우 속성property을 block으로 변경한다)

div{
    display: inline-block;
    width: 50px;
    height: 30px;
    background-color: teal;
}
#inline형식을 block으로 바꾸고 싶을 때, inline-block을 사용했다.
하지만, error와 interactive web을 지원하지 않기 때문에 현재는 거의
쓰지 않는 편. flex란 함수를 사용하여 좀 더 interactive한 web 제작을 한다고 함.
(참고로 block 레이아웃 옆엔 아무것도 올수없고, inline형식은 올순있으나, height와 width 값을 가지지 못함)

#flexbox? flexbox를 적용하기 위해선 child 함수가 아닌 parents 함수에만 적용.
display=flex; 적용을 위한 주축이 존재. 수평의 main axis, 수직의 cross axis.
justify-content:속성값;은 main axis 제어. aligh-item:속성값;은 cross axis 제어.
(but, main axis와 cross axis의 축axis 값은 변경이 가능하기vh는 각 화면 비율의 높이 의미.
 때문에 
main axis=수평, cross axis=수직은 굳이 아니다.)
vh-viewport height. viewport는 computer screen을 의미. 
<!DOCTYPE html>
<html lang="kr">
    <head>
        <style>
             body{
                display: flex;
                margin: 20px;
                height: 100vh;
                justify-content: space-between;
                align-items: center;
                flex-direction: row;
                flex-wrap: wrap;
                
            }

            div{
                display: flex;
                justify-content: center;
                align-items: center;
                width: 300px;
                height: 300px;
                font-size: 20px;
                color: white;
                background-color: teal;
            }
            #second{
                background-color: pink;
            }


            </style>

        <title>Home-My first WEB</title>
    </head>
    <body>
        <div>1</div>
        <div id="second">2</div>
        <div>3</div>

    </body>
</html>

#position fixed를 이용하면 스크롤해도 항상 제자리에 머무른다.
처음 만들어진 자리에 고정 되어있다. 하지만 top, left, right, bottom 중 하나만 수정해도 서로 다른 레이어에 위치하게되어 원래 위치가 무시된다.
positon fixed를 이용하면 가장 윗 단에 위치하게 된다. 

#different{
    top: 5px;
    position: fixed;
    background-color: pink;
    width: 350px;
}
</style>
</head>
<body>
<div>1</div>
<div id="different">2</div>

#position에는 fixed, relative, absolute와 디폴트값으로 static이 있다.
fixed는 레이아웃을 말그대로 fix하는 것. 처음위치를 기준으로 fixed된다. 각 좌표값을 주면
fix위치를 이동시키는 것 또한 가능. fix가 되면 다른 레이아웃 맨 위로 위치.
relative와 absolute는 가장 중요한데, relative는 연관이 있다정도 기억.
absolute는 지정 좌표로 레이아웃을 이동하고 싶을 때 사용하는데, 좌표의 기준을
부모 객체로 지정한다. 만약 position:relative; 부모가 없을 시, body를 기준하여
레이아웃이 이동된다. 우리가 한 객체 내 absolute를 지정한 객체를 이동하고 싶을 때,
부모객체를 지정하여 position:relative; 후 좌표값을 주면 객체 내 레이아웃이 이동한다.

기존 id, class를 통한 element 선택. 그 중 psuedo selector란 새로운
element 지정법 학습. 앞선 방법들이 CSS 모듈에 각각 id와 class를 지정하여
불러오는 방식이었다면, psuedo selector는 별도 추가없이 바로 불러올수있는 방법
기존 #idname{} or .classname{} --> div.value{} id,class보다 효율적.
신기한것:psuedo를 이용하면 n번째 element에 적용할 수 있는데,
객체:nth-child(){
    background-color:blue;
} nth-child(2n or even)라면 짝수만, nth-child(2n-1 or ode)라면 홀수 element 적용

#부모형제관계
부모(div) 안 자식(span) 모두 적용하고 싶다
div span{
    background-color:;
}
부모(div) 안 첫번째, 바로 밑span만 적용하고 싶다.(장남)
div > span{
    background-color:;
}
부모(div) 안이 아닌 바로 다음 span에 적용하고 싶다(형제관계)
div+span{
    background-color:;
}
부모(div) 안이 아는 다음 span에 적용하고 싶다(어떤 형제 관계든)
div ~ span{
    color:;
}

#Attribute selector
psuedo select를 활용한 attribute select.
CSS class, id 활용 없는 속성을 통한 element 선정.
[input type="text" placeholder=""
[input type="password" required placeholder=""]
어떤 속성이든 상관 없다.
ex) input[type="text"]{
    background-color:;
}
input[type="password"]{
    value
}
ex2) 다음 속성이 속하는 모든 element에 적용하고 싶다. ~= 사용(공백X)
input[palceholder~="name"]{
    color:;
}
ex3) 다음 속성이 속하는 모든 element에 적용하고 싶다. *= 사용(공백O)
input[palceholder*="name"]{
    color:;
}
ex4) required가 속해있는 element에 적용하고 싶다. tag:required{}
input:required{
    color:;
}
<style>
span{
    background-color: pink;
    color: tomato;
    padding: 3px;
    border-radius: 10px;
    text-decoration: underline;
}
div p span {
    color: white;
}
p ~ span{
    background-color: teal;
}
input{
    border: 1px solid paleturquoise;
}
input:required{
    border-color: pink;
}
input[placeholder~="name"]{
    background-color: pink;
}
</style>
---------------------------------------------------------------------
<style>
a:visited{
    color: pink;
}
a:hover{
    color:tomato
}
a:focus{
    color:turquoise
}
form{
    border: 1px solid blue;
    display: flex;
    flex-direction: column;
    padding: 20px;
}
form:hover input:focus{
    background-color: aqua;
}
</style>
<title>Home-My first WEB</title>
</head>
<body>
<form>
<input type="text" name="" id="">
<input type="text" name="" id="">
<input type="text" name="" id="">
<input type="text" name="" id="">
</form>
<a href="https://www.daum.net/">daum</a>
</body>
</html>
#state????
Active, hover, focus, focus-within, visited

active 해당 요소를 마우스로 클릭했을 때 효과를 적용

hover 마우스가 해당 요소 위를 지나갈 때 효과를 적용

focus 키보드로 선택되었을 때 효과를 적용

focus-within 부모 요소에게 적용. 자신의 자식 요소 중 하나가 focused되었을 때 효과를 적용

tag:focus{
    background-color:;
} 해당 tag를 클릭했을 때, 속성 변경

tag:hover{
    background-color:;
} 마우스가 해당 태그 위에 올려져있을때, 속성 변경.

tag:visited{
    background-color:;
} 해당 링크를 방문하였을 때, 속성 변경.

tag:focus-within{
    background-color
} focus-within의 경우, 해당 속성을 가진 부모함수의 자식함수 속성을 변경하는 것.
실습한번 해보는 것 추천.

이를 융합한 함수
부모-tag:hover 자식-tag:focus
-> tag:hover tag:focus{
    color:blue;
} 부모 tag에 마우스가 올려져있고, 자식 tag에 focus 했을 때, 효과적용. and의 개념.

#variable(custom property)
:root를 통해 변수var을 저장할 수 있다.
대신 변수 명은 --이름-이름 과 같이 공백 대신 --가 들어가야 함.

:root{
    --main-color:#489ee3;
    --default-margin:10px solid var(--main-color)
}

#animation-Transition
animation 중 transition 학습. 단어 그대로 변환이 일어나는 효과적용.
<style>
    a{
        color:wheat;
        background-color: tomato;
        text-decoration: none;
        padding: 3px 5px;
        border-radius: 5px;
        font-size: 55px;
        transition: all 0.2s ease-in-out;
    }
    a:hover{
        border-radius: 30px;
        color: tomato;
        background-color: wheat;
    }
</style> 다음과 같은 링크가 있다. 첫번째 링크는 속성attribute 부여가 안돼있으며,
두번째 링크의 경우 hover에 대한 attr이 부여되어 있음. transition에 따른 animation을 주기
위해선 attr이 없는 element에 적용을 시켜야 함. 위의 사례로 보면 hover된상태에 따라
transition이 일어나게 하기 위함인데, transition이 hover가 부여된 두번째 링크에 적용되면
마우스가 올려져있을땐 효과가 적용되지만, 때는 순간 적용해제가 됨. 이는 root에
애니메이션을 적용하지 않고 hover에만 적용했기 때문. root에 적용하게 된다면,
일반적인 상태와 더불어 hover 상태에도 적용이 가능하기 때문에 animation 적용을
위해선 root 부분에 반영해야한다.
만약, 각각의 부분에 따로 animation을 주고 싶다면, 콤마(,) 구분 후 단락을 나눠
표현. 

<style>
a:hover{
    border-radius: 90px;
    font-size: 55px;
    color: tomato;
    background-color: wheat;
}
img{
    border: 5px solid black;
    border-radius: 50%;
    transition: all 0.5s ease-in-out;
}
img:hover{
    transform: rotatex(1440deg) rotateY(1440deg) scale(0.5) rotateZ(1440deg);
}
</style>
</head>
#animation-transform
transition이 단순 변환이었다면, transform은 다차원 변환 및 변환조건형성이
가능한 함수.
transition과 달리 root 적용이 아니라 적용시키고자 하는 부분에 직접적용.
위 img:hover 부분에 transform을 직접 적용시킨 것. 또한 transition과 조합하여
다양한 animation 적용이 가능. 가장 중요한 점은 transform이 box나 inline display
변환 을 일으키는 것이 아니라는 점. 단순 픽셀, 차원 단위로 변환을 일으키기 때문에
box와 box가 겹치는 것이다.

<style>
@keyframes "animationName" {
    from{
        transform: rotatex(0) translate(0);
    }
    to{
        transform: rotatex(1440deg) rotateY(1440deg) scale(0.5) rotateZ(1440deg) translate(500px);
    }
    img{
        border: 5px solid black;
        border-radius: 50%;
        animation: animationName 0.5s ease-in-out infinite;
    }}
</style>
#Real animation
앞선 transform과 transition은 진정한 animation이 아니다. hover, active를 통해
진행되기 때문인데, 진짜 animation을 학습하였다.
위 예시와 같이 기본포맷은 @keyframes "애니메이션이름"
이후 from{} to{}를 통해 애니메이션 구현 함수를 넣어주면 되는데, 여기서 from과
to는 어떠한 시점이 아닌 동작구현함수의 시작점과 끝점을 말하는 것. 동작함수를
구현했다면, 해당 tag에 animation: 애니메이션이름 동작시간 ease-in-out infimite;
를 통해 개별 동작 없이 애니메이션의 infinite한 구현이 가능해진다.
다만, 아쉬운점은 from-to까지만의 동작을 구현했기 때문에 to 이후 animation이
부자연스럽다. 
0%{
    transform: rotatex(0) translate(0);
    border-color: black;
}
50%{
    transform: rotateY(1440deg) ;
    border-color: red;
    opacity: 0;
}
100%{
    transform: rotateY(0) translate(0);
    border-color: black;

}
위의 단점을 해결할수있다. from-to 동작구문에서 %구문으로 적용. 구간의 경우,
사용자 임의에 따라 변경될수있음(0to100%,0123,,,100 등) 해당 동작을 적용할 경우
미친 anmiation 감상 가능.

#Responsive Website-media query
Media Query는 오직 CSS만을 이용하여 사용자의 스크린 크기를 알 수 있는 방법.
@media screen and (min-width:601px) and (max-width:1200px) and (orientation: portrait) {
    div{
        background-color: teal;
    }
}
@media screen and 구문이 media query. and () and() 로 조건설정 후 
tag{value}로 설정한다.
orientation:landscape는 핸드폰이 가로모드일때,
orientation:portrait은 세로모드일때를 뜻함.
참고)크롬 내 inspect-elements 작은 icon을 통해 스마트폼 기종에 따른 screen test
가 가능함.
즉, media query는 우리가 직접 조건을 추가할수있는 module